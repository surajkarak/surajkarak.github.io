<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Clustering binding sites based on distance and similarity metrics | Suraj Karakulath</title> <meta name="author" content="Suraj Karakulath"> <meta name="description" content="ETL pipeline for exploring protein binding sites and similarity-based clustering"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://surajkarak.github.io/projects/Clustering-Protein-Structures-Data-Science/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-HCHG0834FS"></script> <script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-HCHG0834FS");</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/">Suraj Karakulath</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">Publications</a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">CV</a> </li> <li class="nav-item "> <a class="nav-link" href="/contact/">Contact</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Clustering binding sites based on distance and similarity metrics</h1> <p class="post-description">ETL pipeline for exploring protein binding sites and similarity-based clustering</p> </header> <article> <p>This was a continuation of my work with the research team under Dr. Petr Popov at Constructor University. In the <a href="https://surajkarak.github.io/projects/Spatiotemporal-analysis-protein-ligand-interactions/">first part of the project</a>, I processed a collection of PDB files, computed the protein-ligand interaction fingerprints, explored their distributions including Gaussian smoothing and time series analysis followed by a visualization and an ETL pipeline to automate the whole workflow.</p> <p>Following this, the research team was looking for ways to derive some patterns among various “binding sites” and “hotspots” in another collection of frames.</p> <p>Binding sites are specific regions on a protein where small molecules - these could be drugs, ligands, or other biomolecules - can attach to interact with the protein. These sites influence the protein’s function, like how the protein behaves, how it interacts with other molecules, or how effective a drug can be. For e.g., in drug design, researchers often want to know exactly where a drug molecule binds on a protein to either block or activate a particular biological process.</p> <p>Understanding these binding sites is central to structural bioinformatics. So in this project, I helped the research team find patterns among the various binding sites and hot spots. I proposed clustering the sites after representing them as numerical vectors, and based on comparable distance metrics, and finally creating a pipeline to automate the tasks from extraction to clustering and visualisations.</p> <h2 id="what-i-used">What I used</h2> <ul> <li>Python in Visual Studio for extraction and analysis</li> <li>Standard data analysis packages - pandas, numpy</li> <li>scipy.stats, statsmodels, sklearn for statistical analysis and time series tests</li> <li>Packages &amp; other tools for visualisation - matplotlib, seaborn, plotly</li> </ul> <h2 id="data-source-and-extraction">Data source and extraction</h2> <p>The data for this project came from precomputed .pkl files - one for each frame containing information about target structure and predicted binding sites with properties. Each .pkl file contained a dict with keys “target” and “sites”.:</p> <ul> <li>Binding site data, for example: <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="sh">'</span><span class="s">file</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">0.pkl</span><span class="sh">'</span><span class="p">,</span>
 <span class="sh">'</span><span class="s">site</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span>
 <span class="sh">'</span><span class="s">residues</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span><span class="sh">'</span><span class="s">A_14_GLY</span><span class="sh">'</span><span class="p">,</span> <span class="sh">'</span><span class="s">A_15_VAL</span><span class="sh">'</span><span class="p">,</span> <span class="p">...],</span>
 <span class="sh">'</span><span class="s">hotspots</span><span class="sh">'</span><span class="p">:</span> <span class="p">[</span>
     <span class="p">{</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">:</span> <span class="nf">array</span><span class="p">([</span><span class="mf">44.39</span><span class="p">,</span> <span class="mf">32.44</span><span class="p">,</span> <span class="mf">13.74</span><span class="p">]),</span> <span class="sh">'</span><span class="s">scores</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">small_molecule</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.99</span><span class="p">}},</span>
     <span class="p">{</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">:</span> <span class="nf">array</span><span class="p">([</span><span class="mf">48.49</span><span class="p">,</span> <span class="mf">33.62</span><span class="p">,</span> <span class="mf">16.08</span><span class="p">]),</span> <span class="sh">'</span><span class="s">scores</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span><span class="sh">'</span><span class="s">ion:-2</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.59</span><span class="p">,</span> <span class="sh">'</span><span class="s">ion:SO4</span><span class="sh">'</span><span class="p">:</span> <span class="mf">0.46</span><span class="p">}}</span>
 <span class="p">]</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div> </div> </li> <li>Target data, for example: <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="sh">'</span><span class="s">file</span><span class="sh">'</span><span class="p">:</span> <span class="sh">'</span><span class="s">0.pkl</span><span class="sh">'</span><span class="p">,</span>
 <span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">:</span> <span class="p">{</span>
  <span class="sh">'</span><span class="s">chain_ids</span><span class="sh">'</span><span class="p">:</span> <span class="p">[...],</span>
  <span class="sh">'</span><span class="s">atom_names</span><span class="sh">'</span><span class="p">:</span> <span class="p">[...],</span>
  <span class="sh">'</span><span class="s">res_ids</span><span class="sh">'</span><span class="p">:</span> <span class="p">[...],</span>
  <span class="sh">'</span><span class="s">coords</span><span class="sh">'</span><span class="p">:</span> <span class="p">[...],</span>
  <span class="sh">'</span><span class="s">elements</span><span class="sh">'</span><span class="p">:</span> <span class="p">[...]</span>
 <span class="p">}}</span>
</code></pre></div> </div> </li> </ul> <h2 id="clustering-methodology">Clustering methodology</h2> <p>In order to cluster the different binding sites, I first had to decide on the appropriate features. After discussing with the research team, I first had to represent each binding site by a “distance” metric. This could take one of three forms.</p> <h3 id="1-residue-overlap-metric---a-simple-intersection-of-the-sets-of-residues-involved-in-two-binding-sites">1. Residue overlap metric - a simple intersection of the sets of residues involved in two binding sites</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">residue_overlap_distance</span><span class="p">(</span><span class="n">site1</span><span class="p">,</span> <span class="n">site2</span><span class="p">):</span>
    <span class="n">residues1</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">site1</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">residues</span><span class="sh">'</span><span class="p">,</span> <span class="p">[]))</span>
    <span class="n">residues2</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">site2</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">residues</span><span class="sh">'</span><span class="p">,</span> <span class="p">[]))</span>
    <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="nf">len</span><span class="p">(</span><span class="n">residues1</span> <span class="o">&amp;</span> <span class="n">residues2</span><span class="p">)</span> <span class="o">/</span> <span class="nf">len</span><span class="p">(</span><span class="n">residues1</span> <span class="o">|</span> <span class="n">residues2</span><span class="p">)</span>
</code></pre></div></div> <h3 id="2-residue-score-metric---directly-using-the-hotspot-scores-as-feature-vectors-representing-each-binding-site-and-finding-the-distance-euclidean-l1-or-jaccard-distance">2. Residue score metric - directly using the hotspot “scores” as feature vectors representing each binding site and finding the distance (Euclidean, L1, or Jaccard distance)</h3> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">residue_score_distance</span><span class="p">(</span><span class="n">site1</span><span class="p">,</span> <span class="n">site2</span><span class="p">,</span> <span class="n">distancetype</span><span class="p">):</span>
    <span class="n">res_scores_1</span> <span class="o">=</span> <span class="n">site1</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">residue_scores</span><span class="sh">'</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">res_scores_2</span> <span class="o">=</span> <span class="n">site2</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="sh">'</span><span class="s">residue_scores</span><span class="sh">'</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">rnames</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nb">set</span><span class="p">.</span><span class="nf">union</span><span class="p">(</span><span class="nf">set</span><span class="p">(</span><span class="n">res_scores_1</span><span class="p">.</span><span class="nf">keys</span><span class="p">()),</span> <span class="nf">set</span><span class="p">(</span><span class="n">res_scores_2</span><span class="p">.</span><span class="nf">keys</span><span class="p">())))</span>
    <span class="n">res_scores_1</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">.</span><span class="nf">fromkeys</span><span class="p">(</span><span class="n">rnames</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">**</span><span class="n">res_scores_1</span><span class="p">}</span>
    <span class="n">res_scores_2</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="nb">dict</span><span class="p">.</span><span class="nf">fromkeys</span><span class="p">(</span><span class="n">rnames</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">**</span><span class="n">res_scores_2</span><span class="p">}</span>
    <span class="n">res_scores_1</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">res_scores_1</span><span class="p">.</span><span class="nf">values</span><span class="p">()),</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    <span class="n">res_scores_2</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">asarray</span><span class="p">(</span><span class="nf">list</span><span class="p">(</span><span class="n">res_scores_2</span><span class="p">.</span><span class="nf">values</span><span class="p">()),</span> <span class="n">np</span><span class="p">.</span><span class="n">float32</span><span class="p">)</span>
    
    <span class="n">dist</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">sqrt</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">sum</span><span class="p">((</span><span class="n">res_scores_1</span> <span class="o">-</span> <span class="n">res_scores_2</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="n">dist</span>
</code></pre></div></div> <h3 id="3-distance-vector-metric">3. Distance vector metric</h3> <p>This third approach is the most complex. It builds a consistent numerical representation of each binding site by encoding how its atoms relate to a global set of atoms of interest. This involved a few steps:</p> <h4 id="1-identifying-atoms-in-hotspots">1. Identifying atoms in hotspots</h4> <p>A hotspot is essentially a functional region of a binding site. I needed to know exactly which atoms belonged to each hotspot. This involved mapping residue identifiers in a binding site to the corresponding atoms in the target structure. It ensures the right atoms are pulled out from the matching .pkl target file and records their details (chain ID, residue ID, atom name, element, and coordinates).</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_atoms_in_binding_site</span><span class="p">(</span><span class="n">binding_site</span><span class="p">):</span>  
    <span class="n">file_name</span> <span class="o">=</span> <span class="n">binding_site</span><span class="p">[</span><span class="sh">'</span><span class="s">file</span><span class="sh">'</span><span class="p">]</span> 
    <span class="n">target</span><span class="o">=</span> <span class="p">[</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">all_target_data</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">file</span><span class="sh">'</span><span class="p">]</span> <span class="ow">in</span> <span class="n">file_name</span><span class="p">]</span> <span class="c1"># extra check to make sure that the atoms are from the residues in the same pkl file 
</span>    <span class="n">target_data</span> <span class="o">=</span> <span class="nf">next</span><span class="p">((</span><span class="n">entry</span> <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">target</span> <span class="k">if</span> <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">file</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">file_name</span><span class="p">),</span> <span class="bp">None</span><span class="p">)</span>
    <span class="n">binding_site_residues</span> <span class="o">=</span> <span class="n">binding_site</span><span class="p">[</span><span class="sh">'</span><span class="s">site</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">residues</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">parsed_residues</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">residue</span> <span class="ow">in</span> <span class="n">binding_site_residues</span><span class="p">:</span>
		        <span class="n">chain_id</span><span class="p">,</span> <span class="n">res_id</span><span class="p">,</span> <span class="n">res_name</span> <span class="o">=</span> <span class="n">residue</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">_</span><span class="sh">'</span><span class="p">)</span>
		        <span class="n">parsed_residues</span><span class="p">.</span><span class="nf">append</span><span class="p">((</span><span class="n">chain_id</span><span class="p">,</span> <span class="nf">int</span><span class="p">(</span><span class="n">res_id</span><span class="p">),</span> <span class="n">res_name</span><span class="p">))</span>        
		     
		<span class="n">chain_ids</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">chain_ids</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">res_ids</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">res_ids</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">res_names</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">res_names</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">atom_names</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">atom_names</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">coords</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">coords</span><span class="sh">'</span><span class="p">]</span>
		<span class="n">elements</span> <span class="o">=</span> <span class="n">target_data</span><span class="p">[</span><span class="sh">'</span><span class="s">target</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">elements</span><span class="sh">'</span><span class="p">]</span>
		
		<span class="n">atoms_in_site</span> <span class="o">=</span> <span class="p">[]</span>
		<span class="k">for</span> <span class="n">chain_id</span><span class="p">,</span> <span class="n">res_id</span><span class="p">,</span> <span class="n">res_name</span> <span class="ow">in</span> <span class="n">parsed_residues</span><span class="p">:</span>
		    <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="n">chain_ids</span> <span class="o">==</span> <span class="n">chain_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">res_ids</span> <span class="o">==</span> <span class="n">res_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">res_names</span> <span class="o">==</span> <span class="n">res_name</span><span class="p">)</span>
		    <span class="n">matching_indices</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="n">mask</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
		
		    <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">matching_indices</span><span class="p">:</span>
		        <span class="n">atoms_in_site</span><span class="p">.</span><span class="nf">append</span><span class="p">({</span>
		            <span class="sh">'</span><span class="s">chain_id</span><span class="sh">'</span><span class="p">:</span> <span class="n">chain_id</span><span class="p">,</span>
		            <span class="sh">'</span><span class="s">res_id</span><span class="sh">'</span><span class="p">:</span> <span class="n">res_id</span><span class="p">,</span>
		            <span class="sh">'</span><span class="s">res_name</span><span class="sh">'</span><span class="p">:</span> <span class="n">res_name</span><span class="p">,</span>
		            <span class="sh">'</span><span class="s">atom_name</span><span class="sh">'</span><span class="p">:</span> <span class="n">atom_names</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
		            <span class="sh">'</span><span class="s">coords</span><span class="sh">'</span><span class="p">:</span> <span class="n">coords</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="nf">tolist</span><span class="p">(),</span>
		            <span class="sh">'</span><span class="s">element</span><span class="sh">'</span><span class="p">:</span> <span class="n">elements</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span>
		        <span class="p">})</span>
		
		<span class="k">return</span> <span class="n">atoms_in_site</span>
</code></pre></div></div> <h4 id="2-defining-a-global-set-of-atoms">2. Defining a global set of atoms</h4> <p>Once atoms are extracted from all binding sites, I collected them into a global catalogue of unique atoms by:</p> <ul> <li>Looping through all sites, runs, getting their atoms, and flattening the results</li> <li>Assigning each atom a unique identifier string, like “A_14_GLY_CA”</li> <li>Storing these unique atoms in an OrderedSet, which ensures that the feature vectors will always follow the same order</li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">atoms_of_interest</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">):</span> 
    <span class="n">atoms_of_interest</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">binding_sites</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="nf">get_atoms_in_binding_site</span><span class="p">(</span><span class="n">site</span><span class="p">)</span> 
        <span class="n">atoms_of_interest</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
    <span class="n">all_atoms</span> <span class="o">=</span> <span class="p">[</span>
        <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">chain_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_name</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">atom_name</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span> 
        <span class="k">for</span> <span class="n">atom_list</span> <span class="ow">in</span> <span class="n">atoms_of_interest</span> 
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atom_list</span>
        <span class="p">]</span>
    <span class="n">unique_atoms</span> <span class="o">=</span> <span class="nc">OrderedSet</span><span class="p">(</span><span class="n">all_atoms</span><span class="p">)</span> <span class="c1"># Ordered set to maintain order in the calculation of the hotspot distances to atoms and binding vector for each site
</span>    <span class="n">atoms_of_interest_flat</span> <span class="o">=</span> <span class="p">[</span><span class="n">atom</span> <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">atoms_of_interest</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>  <span class="c1"># atoms_of_interest_flat has to be a dictionary
</span>    <span class="nf">print</span><span class="p">(</span><span class="sh">"</span><span class="s">Set of atoms of interest created (Distance Vector Method)</span><span class="sh">"</span><span class="p">)</span> 
    <span class="k">return</span> <span class="n">unique_atoms</span><span class="p">,</span> <span class="n">atoms_of_interest_flat</span> 
</code></pre></div></div> <p>This global set of atoms was crucial: it defines the dimensions of the vector space in which all binding sites will be represented.</p> <h4 id="3-looking-up-atom-coordinates">3. Looking up atom coordinates</h4> <p>I also wanted to retrieve the coordinates for any given atom ID. It searches through the global flat list of atom dictionaries (atoms_of_interest_flat) and returns the XYZ coordinates.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_atom_coordinates</span><span class="p">(</span><span class="n">atom_data</span><span class="p">):</span>  
   
    <span class="n">chain_id</span><span class="p">,</span> <span class="n">res_id</span><span class="p">,</span> <span class="n">res_name</span><span class="p">,</span> <span class="n">atom_name</span> <span class="o">=</span> <span class="n">atom_data</span>
    <span class="k">for</span> <span class="n">entry</span> <span class="ow">in</span> <span class="n">atoms_of_interest_flat</span><span class="p">:</span>  <span class="c1"># atoms_of_interest_flat has to be global and in a dictionary format
</span>        <span class="nf">if </span><span class="p">(</span>
            <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">chain_id</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">chain_id</span> <span class="ow">and</span>
            <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">res_id</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="nf">int</span><span class="p">(</span><span class="n">res_id</span><span class="p">)</span> <span class="ow">and</span>
            <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">res_name</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">res_name</span> <span class="ow">and</span>
            <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">atom_name</span><span class="sh">'</span><span class="p">]</span> <span class="o">==</span> <span class="n">atom_name</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="n">entry</span><span class="p">[</span><span class="sh">'</span><span class="s">coords</span><span class="sh">'</span><span class="p">]</span>
    <span class="k">raise</span> <span class="nc">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Coordinates not found for atom: </span><span class="si">{</span><span class="n">atom_data</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span>
</code></pre></div></div> <p>This step is what enables distance calculations later on.</p> <h4 id="4-building-the-binding-site-vector">4. Building the binding site vector</h4> <p>The heart of the method is binding_site_vector(binding_site, unique_atoms). For a given site, it constructs a fixed-length vector whose entries correspond to the global set of unique atoms.</p> <p>Here’s the idea:</p> <ul> <li>Initialize the vector with a large dummy value (e.g. 10.0) for all atoms.</li> <li>For each hotspot in the binding site, compute the Euclidean distance between the hotspot center and the coordinates of each atom in the site.</li> <li>Update the vector entry for that atom with this distance.</li> </ul> <p>Each hotspot generates its own vector. Then, for the final representation of the binding site, the code takes the minimum distance across all hotspots for each atom. This way, the binding site vector encodes the closest approach of its atoms to each hotspot.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">binding_site_vector</span><span class="p">(</span><span class="n">binding_site</span><span class="p">,</span> <span class="n">unique_atoms</span><span class="p">):</span>
    <span class="c1">#dummy vector for all unique atoms with a large default value (e.g., 10.0) to keep vector lengths same, i.e. equal to length of unique atoms
</span>    <span class="n">dummy_vector</span> <span class="o">=</span> <span class="p">{</span><span class="n">atom</span><span class="p">:</span> <span class="mf">10.0</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">unique_atoms</span><span class="p">}</span>
    <span class="n">residues_in_site</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span><span class="n">binding_site</span><span class="p">[</span><span class="sh">'</span><span class="s">site</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">residues</span><span class="sh">'</span><span class="p">])</span> 

    <span class="c1"># get atoms from residues 
</span>    <span class="n">atoms_in_site</span> <span class="o">=</span> <span class="nf">set</span><span class="p">(</span>
        <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">chain_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_name</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">atom_name</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span>
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms_of_interest_flat</span>
        <span class="k">if</span> <span class="sa">f</span><span class="sh">"</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">chain_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_id</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="s">_</span><span class="si">{</span><span class="n">atom</span><span class="p">[</span><span class="sh">'</span><span class="s">res_name</span><span class="sh">'</span><span class="p">]</span><span class="si">}</span><span class="sh">"</span> <span class="ow">in</span> <span class="n">residues_in_site</span>
    <span class="p">)</span>

    <span class="n">hotspot_vectors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">hotspot</span> <span class="ow">in</span> <span class="n">binding_site</span><span class="p">[</span><span class="sh">'</span><span class="s">site</span><span class="sh">'</span><span class="p">][</span><span class="sh">'</span><span class="s">hotspots</span><span class="sh">'</span><span class="p">]:</span>
        <span class="n">hotspot_coords</span> <span class="o">=</span> <span class="n">hotspot</span><span class="p">[</span><span class="sh">'</span><span class="s">center</span><span class="sh">'</span><span class="p">]</span>   
        <span class="n">hotspot_vector</span> <span class="o">=</span> <span class="n">dummy_vector</span><span class="p">.</span><span class="nf">copy</span><span class="p">()</span>  
        
        <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">unique_atoms</span><span class="p">.</span><span class="nf">intersection</span><span class="p">(</span><span class="n">atoms_in_site</span><span class="p">):</span>
            <span class="n">atom_data</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="nf">split</span><span class="p">(</span><span class="sh">'</span><span class="s">_</span><span class="sh">'</span><span class="p">)</span>
            <span class="n">atom_coords</span> <span class="o">=</span> <span class="nf">get_atom_coordinates</span><span class="p">(</span><span class="n">atom_data</span><span class="p">)</span>  
            <span class="n">distance</span> <span class="o">=</span> <span class="n">np</span><span class="p">.</span><span class="n">linalg</span><span class="p">.</span><span class="nf">norm</span><span class="p">(</span><span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">hotspot_coords</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="p">.</span><span class="nf">array</span><span class="p">(</span><span class="n">atom_coords</span><span class="p">))</span>
            <span class="n">hotspot_vector</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">=</span> <span class="n">distance</span> <span class="c1"># updates the distance for only that element of the hotspot vector where the id matches this particular atom
</span>
        <span class="c1"># add the hotspot vector to the list of vectors
</span>        <span class="n">hotspot_vectors</span><span class="p">.</span><span class="nf">append</span><span class="p">(</span><span class="n">hotspot_vector</span><span class="p">)</span>

    <span class="c1"># Calculate the binding site vector as the minimum distance across all hotspots for each atom
</span>    <span class="n">binding_site_vector</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nf">min</span><span class="p">(</span><span class="n">hotspot_vector</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="k">for</span> <span class="n">hotspot_vector</span> <span class="ow">in</span> <span class="n">hotspot_vectors</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">unique_atoms</span> 
    <span class="p">]</span>

    <span class="k">return</span> <span class="n">binding_site_vector</span>

</code></pre></div></div> <p>The result is a dense numerical vector of equal length for all binding sites, ready for pairwise comparison</p> <h3 id="computing-the-distance-between-2-distance-vectors-and-distance-matrix">Computing the distance between 2 distance vectors and distance matrix</h3> <p>Once I had site vectors, it was just a matter of computing the distance (using (L2/Euclidean or L1/Manhattan etc.) between 2 vectors to get this third type of distance metric.</p> <p>For each type of distance metric, it was necessary to compute a distance matrix. The distance matrix is a 2D array where entry (i, j) represents the distance between binding site i and binding site j. And although the binding sites themselves are the “items” being clustered, each row in the distance matrix corresponds to a binding site, and the algorithm assigns a cluster label to that row.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">pairwise_distances_with_library</span><span class="p">(</span><span class="n">sites</span><span class="p">,</span> <span class="n">distance_func</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span> 
    <span class="k">def</span> <span class="nf">distance_wrapper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">distance_func</span><span class="p">(</span><span class="n">sites</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">sites</span><span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">j</span><span class="p">[</span><span class="mi">0</span><span class="p">])],</span> <span class="n">distance_type</span><span class="p">)</span>
    
    <span class="n">indices</span> <span class="o">=</span> <span class="nf">list</span><span class="p">(</span><span class="nf">range</span><span class="p">(</span><span class="nf">len</span><span class="p">(</span><span class="n">sites</span><span class="p">)))</span>
    <span class="n">condensed_matrix</span> <span class="o">=</span> <span class="nf">pdist</span><span class="p">([[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">],</span> <span class="n">metric</span><span class="o">=</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nf">distance_wrapper</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">))</span>
    
    <span class="k">return</span> <span class="nf">squareform</span><span class="p">(</span><span class="n">condensed_matrix</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">calculate_distance_matrix</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">,</span> <span class="n">distance_metric</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="sh">'</span><span class="s">residue_overlap</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">pairwise_distances_with_library</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">,</span> <span class="n">residue_overlap_distance</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="sh">'</span><span class="s">residue_score</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">pairwise_distances_with_library</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">,</span> <span class="n">residue_score_distance</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">distance_metric</span> <span class="o">==</span> <span class="sh">'</span><span class="s">distance_vector</span><span class="sh">'</span><span class="p">:</span>
            <span class="k">global</span> <span class="n">unique_atoms</span><span class="p">,</span> <span class="n">atoms_of_interest_flat</span>
            <span class="n">unique_atoms</span><span class="p">,</span> <span class="n">atoms_of_interest_flat</span> <span class="o">=</span> <span class="nf">atoms_of_interest</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">)</span>
            <span class="k">return</span> <span class="nf">pairwise_distances_with_library</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">,</span> <span class="n">distance_between_vectors</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>

<span class="n">distance_matrix</span> <span class="o">=</span> <span class="nf">calculate_distance_matrix</span><span class="p">(</span><span class="n">binding_sites</span><span class="p">,</span> <span class="n">distance_metric</span><span class="p">,</span> <span class="n">distance_type</span><span class="p">)</span>

</code></pre></div></div> <p>This is unlike traditional clustering applications in “business” where a product or item is assigned a cluster based on its features. In fact, you can think of the distance matrix as a collection of items with their features, except the items themselves are entire rows (binding sites) and the features are the columns. Or in other words, instead of using the raw attributes of a binding site, we use its pattern of distances to every other binding site as its effective “feature vector.”</p> <h3 id="clustering-algorithms">Clustering Algorithms</h3> <p>For each distance metric, I used four clustering algorithms as the research team wanted the flexibility of using anyone of them based on their needs.</p> <h4 id="agglomerative-clustering">Agglomerative Clustering</h4> <p>Builds a hierarchy of clusters by repeatedly merging the closest pair of sites. Best for small to medium datasets where the hierarchy itself is meaningful.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">agglom_model</span> <span class="o">=</span> <span class="nc">AgglomerativeClustering</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="nf">len</span><span class="p">(</span><span class="n">clusters</span><span class="p">),</span> <span class="n">metric</span><span class="o">=</span><span class="sh">'</span><span class="s">precomputed</span><span class="sh">'</span><span class="p">,</span> <span class="n">linkage</span><span class="o">=</span><span class="n">linkage_method</span><span class="p">)</span>
<span class="n">cluster_labels</span> <span class="o">=</span> <span class="n">agglom_model</span><span class="p">.</span><span class="nf">fit_predict</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/clustering-protein/dendogram-hierarchical-clustering-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/clustering-protein/dendogram-hierarchical-clustering-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/clustering-protein/dendogram-hierarchical-clustering-1400.webp"></source> <img src="/assets/img/clustering-protein/dendogram-hierarchical-clustering.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Reachability plot" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h4 id="dbscan">DBSCAN</h4> <p>Groups sites that are close together in dense regions and labels isolated points as noise. This is good when you suspect that some binding sites don’t really belong to any cluster but shouldn’t be forced into one.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">dbscan</span> <span class="o">=</span> <span class="nc">DBSCAN</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="sh">'</span><span class="s">precomputed</span><span class="sh">'</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="n">epsilon</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="n">minimum_samples</span><span class="p">)</span>
<span class="n">dbscan_labels</span> <span class="o">=</span> <span class="n">dbscan</span><span class="p">.</span><span class="nf">fit_predict</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
</code></pre></div></div> <h4 id="optics">OPTICS</h4> <p>Similar to DBSCAN, but more flexible. Instead of fixing one density threshold, this explores clusters across a range of densities and produces a reachability plot.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="n">optics</span> <span class="o">=</span> <span class="nc">OPTICS</span><span class="p">(</span><span class="n">metric</span><span class="o">=</span><span class="sh">'</span><span class="s">precomputed</span><span class="sh">'</span><span class="p">,</span> <span class="n">min_samples</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">xi</span><span class="o">=</span><span class="n">xi</span><span class="p">,</span> <span class="n">min_cluster_size</span><span class="o">=</span><span class="n">minimum_cluster_size</span><span class="p">)</span>
<span class="n">optics_labels</span> <span class="o">=</span> <span class="n">optics</span><span class="p">.</span><span class="nf">fit_predict</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
</code></pre></div></div> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/clustering-protein/reachability-plot-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/clustering-protein/reachability-plot-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/clustering-protein/reachability-plot-1400.webp"></source> <img src="/assets/img/clustering-protein/reachability-plot.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Reachability plot" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h4 id="meanshift">MeanShift</h4> <p>Shifts points toward the densest regions in the data until stable clusters form. It doesn’t need you to predefine the number of clusters, and it’s a good choice when clusters are expected to be roughly “blob-shaped” around centres.</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mean_shift</span> <span class="o">=</span> <span class="nc">MeanShift</span><span class="p">()</span>
<span class="n">mean_shift_labels</span> <span class="o">=</span> <span class="n">mean_shift</span><span class="p">.</span><span class="nf">fit_predict</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
</code></pre></div></div> <p>Since binding site vectors are high-dimensional, t-SNE plots can help project them down into 2D for visualization.</p> <p>For example:</p> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">embedding</span> <span class="o">=</span> <span class="nc">TSNE</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="sh">'</span><span class="s">precomputed</span><span class="sh">'</span><span class="p">,</span> <span class="n">init</span><span class="o">=</span><span class="sh">'</span><span class="s">random</span><span class="sh">'</span><span class="p">).</span><span class="nf">fit_transform</span><span class="p">(</span><span class="n">distance_matrix</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">6</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">cluster_id</span> <span class="ow">in</span> <span class="n">np</span><span class="p">.</span><span class="nf">unique</span><span class="p">(</span><span class="n">cluster_labels</span><span class="p">):</span>
            <span class="n">cluster_points</span> <span class="o">=</span> <span class="n">embedding</span><span class="p">[</span><span class="n">cluster_labels</span> <span class="o">==</span> <span class="n">cluster_id</span><span class="p">]</span>
            <span class="n">plt</span><span class="p">.</span><span class="nf">scatter</span><span class="p">(</span><span class="n">cluster_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">cluster_points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="sa">f</span><span class="sh">'</span><span class="s">Cluster </span><span class="si">{</span><span class="n">cluster_id</span><span class="si">}</span><span class="sh">'</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">title</span><span class="p">(</span><span class="sh">'</span><span class="s">Clusters (Agglomerative) visualized Using t-SNE</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">xlabel</span><span class="p">(</span><span class="sh">'</span><span class="s">t-SNE Dimension 1</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">ylabel</span><span class="p">(</span><span class="sh">'</span><span class="s">t-SNE Dimension 2</span><span class="sh">'</span><span class="p">)</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">legend</span><span class="p">()</span>
        <span class="n">plt</span><span class="p">.</span><span class="nf">show</span><span class="p">()</span>
</code></pre></div></div> <p>Points that end up close together in the plot are generally similar in the original feature space, giving an intuitive view of cluster separation.</p> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/clustering-protein/mean-shift-t-sne-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/clustering-protein/mean-shift-t-sne-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/clustering-protein/mean-shift-t-sne-1400.webp"></source> <img src="/assets/img/clustering-protein/mean-shift-t-sne.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" title="Meanshift t-SNE plot" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h2 id="deploying-into-production-with-an-etl-pipeline">Deploying into production with an ETL pipeline</h2> <p>Once the logic and workflow was agreed on, the research team wanted a configurable pipeline where they could:</p> <ul> <li>Choose the metric type (residue_overlap, residue_score, or distance_vector) and for each of these, additional parameters like options normalisation: min, max, average, or union.</li> <li>Select the distance metric (Euclidean, Manhattan, cosine, Jaccard, etc.)</li> <li>Experiment with different clustering algorithms (hierarchical, KMeans, DBSCAN, HDBSCAN)</li> <li>Control other parameters like the subset of binding sites, dimensionality reduction method, or output visualisations</li> </ul> <p>To support this, I built a single production-ready Python file (clustering_pipeline.py) that functions as an ETL pipeline:</p> <ul> <li> <strong>Extraction -</strong> with functions for loading binding site and atom data from the provided .pkl files. And also for handling mapping atoms and constructing the unique atom identifiers.</li> <li> <strong>Transformation -</strong> functions to calculate the <ul> <li>residue_overlap_distance, residue_score_distance and distance_between_vectors for the 3 methods, each taking in 2 sites as arguments. The 3rd function also depended on other helper functions like:</li> <li>get_atoms_in_binding_site, atoms_of_interest (to list all unique atoms from all binding sites in all files), get_atom_coordinates (to get coordinates for atom specified)and binding_site_vector (to calculate the vector for a binding site based on the distances between hotspots and unique atoms)</li> <li>pairwise_distances_with_library – builds pairwise distance matrices between binding sites for the chosen distance metric.</li> </ul> </li> <li> <strong>Loading &amp; Analysis</strong> <ul> <li>perform_clustering (that takes in the distance_matrix and other clustering_args ) – applies the chosen clustering algorithm (hierarchical, KMeans, DBSCAN, HDBSCAN) and generates t-SNE plots for visualization, while also returning the clustering labels</li> <li>a mapping function that takes in the binding site (or a subset of the binding site for testing calculations quickly) and clustering labels to output a JSON file that pairs the binding site with the cluster label.</li> </ul> </li> </ul> <div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mapping</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
    <span class="n">labels</span> <span class="o">=</span> <span class="p">[</span><span class="nf">int</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">]</span>
    <span class="n">subset_with_labels</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">{</span><span class="sh">"</span><span class="s">residues</span><span class="sh">"</span><span class="p">:</span> <span class="n">site</span><span class="p">[</span><span class="sh">"</span><span class="s">site</span><span class="sh">"</span><span class="p">].</span><span class="nf">get</span><span class="p">(</span><span class="sh">"</span><span class="s">residues</span><span class="sh">"</span><span class="p">,</span> <span class="p">[]),</span> <span class="sh">"</span><span class="s">cluster_label</span><span class="sh">"</span><span class="p">:</span> <span class="n">label</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">site</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nf">zip</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">output_file</span> <span class="o">=</span> <span class="sh">"</span><span class="s">bindingsites_with_labels.json</span><span class="sh">"</span>
    <span class="k">with</span> <span class="nf">open</span><span class="p">(</span><span class="n">output_file</span><span class="p">,</span> <span class="sh">"</span><span class="s">w</span><span class="sh">"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">json</span><span class="p">.</span><span class="nf">dump</span><span class="p">(</span><span class="n">subset_with_labels</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="mi">4</span><span class="p">))</span>
</code></pre></div></div> <p>So the output JSON would contain elements like this:</p> <div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"residues"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"A_14_GLY"</span><span class="p">,</span><span class="w"> </span><span class="s2">"A_15_VAL"</span><span class="p">,</span><span class="w"> </span><span class="err">...</span><span class="p">],</span><span class="w">
        </span><span class="nl">"cluster_label"</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="p">{</span><span class="w">
        </span><span class="nl">"residues"</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="s2">"A_20_SER"</span><span class="p">,</span><span class="w"> </span><span class="s2">"A_21_THR"</span><span class="p">,</span><span class="w"> </span><span class="err">...</span><span class="p">],</span><span class="w">
        </span><span class="nl">"cluster_label"</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="w">
    </span><span class="p">},</span><span class="w">
    </span><span class="err">...</span><span class="w">
</span><span class="p">]</span><span class="w">
</span></code></pre></div></div> <ul> <li> <strong>Configuration Layer</strong> <ul> <li>A core function “cluster” to take in a JSON file path as the argument, which contains all the parameters for the pipeline such as the location of the folder with the pkl files, a subset to analyse if needed, distance metric types, and specifically what type of distance (Euclidean, Manhattan, Jaccard etc.), clustering algorithm, number of clusters, and other clustering parameters). The clustering parameters JSON file could look something like this: <div class="language-json highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
</span><span class="nl">"path_to_pkl_files"</span><span class="p">:</span><span class="w"> </span><span class="s2">"/path/to/pkl-folder/kras_md_sites_1"</span><span class="p">,</span><span class="w">
</span><span class="nl">"subset_to_analyse"</span><span class="p">:</span><span class="w"> </span><span class="mi">50</span><span class="p">,</span><span class="w"> 
</span><span class="nl">"distance_metric"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"metric_type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"distance_vector"</span><span class="p">,</span><span class="w"> 
  </span><span class="nl">"distance_type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"jaccard"</span><span class="w">
</span><span class="p">},</span><span class="w">
</span><span class="nl">"clustering_model"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
  </span><span class="nl">"type"</span><span class="p">:</span><span class="w"> </span><span class="s2">"optics"</span><span class="p">,</span><span class="w">
  </span><span class="nl">"parameters"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
</span><span class="nl">"min_samples"</span><span class="p">:</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w">
 </span><span class="nl">"xi"</span><span class="p">:</span><span class="w"> </span><span class="mf">0.05</span><span class="p">,</span><span class="w"> 
 </span><span class="nl">"min_cluster_size"</span><span class="p">:</span><span class="w"> </span><span class="mf">0.1</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div> </div> </li> </ul> </li> <li> <strong>Main Function</strong> <ul> <li>The <em>*main*</em> function which orchestrates the end-to-end pipeline, accepting the path to the JSON file as input and calling the cluster function with this JSON file path to run the entire workflow. <div class="language-python highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="sh">'</span><span class="s">__main__</span><span class="sh">'</span><span class="p">:</span>
  <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="p">.</span><span class="nc">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="sh">"</span><span class="s">Cluster binding sites from PKL files (frames)</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">parser</span><span class="p">.</span><span class="nf">add_argument</span><span class="p">(</span><span class="sh">'</span><span class="s">--json_path</span><span class="sh">'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">Path</span><span class="p">,</span> <span class="nb">help</span><span class="o">=</span><span class="sh">"</span><span class="s">Path to the folder containing the JSON files with the parameters</span><span class="sh">"</span><span class="p">)</span>
  <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="p">.</span><span class="nf">parse_args</span><span class="p">()</span>
  <span class="nf">print</span><span class="p">(</span><span class="sa">f</span><span class="sh">"</span><span class="s">Folder Path: </span><span class="si">{</span><span class="n">args</span><span class="p">.</span><span class="n">json_path</span><span class="si">}</span><span class="sh">"</span><span class="p">)</span> 
  <span class="nf">cluster</span><span class="p">(</span><span class="n">args</span><span class="p">.</span><span class="n">json_path</span><span class="p">)</span>
</code></pre></div> </div> <p>This structure allowed the research team to test out with different settings and parameters without editing the codebase — they only need to update the JSON configuration file.</p> </li> </ul> </li> </ul> <h2 id="some-challenges-and-lessons-from-this-project">Some challenges and lessons from this project</h2> <ul> <li> <strong>The data extraction</strong>: The JSON files accompanying the PDB data included multiple layers of nested dictionaries and lists, containing various residues, targets and their properties and metrics</li> <li> <strong>The subject matter:</strong> Initially, it was hard to wrap my head around the goal of the task, and what binding sites and targets were. The complex JSON structures in the data files did not make things easier. I had to discuss with the research team and subject matter experts in detail a few times before getting clarity.</li> <li> <strong>Representation matters</strong>: A binding site isn’t naturally a vector - deciding whether to use residue overlap, hotspot scores, or atom distances fundamentally changes the clustering.</li> <li> <strong>Cluster count variability</strong>: MeanShift might found 3 clusters while Agglomerative found 19 - not “wrong”, just a reflection of different assumptions.</li> <li> <strong>Mapping back to binding sites</strong>: After clustering, the key was mapping each binding site back to its residues/atoms to interpret what the clusters actually represent.</li> <li> <strong>The ETL pipeline</strong>: This was tricky due to the number of helper functions involved and how they depended on each other. But testing with smaller subsets for quick checks got me there eventually.</li> </ul> </article> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2025 Suraj Karakulath. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>